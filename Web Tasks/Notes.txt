Lecture 1 : Execution Context

Que : How JavaScript works?
Ans : Everything in JavaScript happens inside an "execution context".

Execution context has two component
    1. memory component[variable environment] 
    -This is the place where all variables and functions are stored as key value pairs. eg-{key: value ||  n:2;} 

    2. code component[Thread of execution]
    -This is the place where code is executed one line at a time

Note-
    *JavaScript is a synchronous single-threaded language

    -Single threaded means JavaScript can execute one command at a time
    -Synchronous single-threaded that means JavaScript can execute one command at a time in a specific order.




Lecture 2 : How Execution of a Program will happen

1. Whenever any JavaScript code is executed an execution context is created and it is the Global Execution Context.
2. An Execution Context is basically a box which has two components called Memory Component(Variable Environment) and Code Component(Thread Of Execution).
3. The Execution context is created in two phases
   
   a. Memory Creation Phase : In this Phase, Memory is allocated to all the variables and functions which are present in the global scope. it stores Undefined (Special keyword) in case of variables and literally the whole function code in case of functions.
   
   b. Code Execution Phase : In this Phase, code is executed line by line.  in this phase  thread execution happens and all the variables get their actual values which were assigned to them and as function is invoked, a new execution environment gets created in the code part, and again there are two phases, memory allocation phase and code execution phase. And the cycle repeats.

4. Whenever a function invoked. the all new execution context is created and same process of creation of execution context is followed again.

Note: 
    function hero(int a, int b) -> parameter
    hero(1, 2) -> argument

5. If there is any function parameter then it is also allocated memory while creating the execution context of the function.

6. Whenever return keyword is encountered , it means the task of function is over and it returns back the control of the program back to the place where it was invoked. and with this this execution context is deleted from stack.

7. Call Stack is basically a stack which maintains the order of execution of execution context. Whenever a code is executed the Global Execution Context is pushed into the stack first and later on as per the function invocation the  execution context is pushed into the stack. When the function code is done executing the execution context is popped out and last the Global Execution Context s also deleted.
call stack is also known as : execution context stack, program stack, control stack, runtime stack, machine stack



Lecture 3 : Hoisting

1. Hoisting in JavaScript is a process in which all the Variables, Functions and Class defination are declared BEFORE execution of the code 
2. Variables are initialised to UNDEFINED when they are declared and Function defination is stored AS IT IS.
3. They are declared in Memory Allocation Phase in the Memory Component of Execution Context, so we can use them even BEFORE they are declared.
4. UNDEFINED means Variable has been declared but value is not ASSIGNED but NOT DEFINED means Variables is NOT DECLARED. 
5. When we assign Variable to a Function defination, we CAN NOT call this Variable as Function BEFORE declaration as it will behave as a Variable with UNDEFINED value.



Lecture 4 : Function

1. We learnt how functions work in JS.
2. At first a global execution context is created, which consists of Memory and code and has 2 phases: Memory allocation phase and code execution phase.
3. In the first phase, the variables are assigned "undefined" while functions have their own code.
4. Whenever there is a function declaration in the code, a separate local execution context gets created having its own phases and is pushed into the call stack.
5. Once the function ends, the EC is removed from the call stack.
6. When the program ends, even the global EC is pulled out of the call stack.



Lecture 5 : Shortest Program in JS


1.Shortest JavaScript Program is  an empty file. Yes, Though there is nothing in the code but still the JS Engine still creates the Execution context and sets up the memory.

2. Apart from this, JS Engine also creates a Window object for us in Global Space.

3. In the Global level (Window === this) in case of browsers. So Basically when any program is run a Global Object(Window) is created , Global Execution context is created and a "this" is created.

4. Any code in JavaScript which is not inside a function is in Global Space.

5. Whatever code we write in global space gets attached to this global object(Window).

Note : 
    a. Global Space = the memory(Variable environment) of Global Execution Context.
    b. Local Space =  the memory(Variable environment) of a particular function's Execution Context that you are currently in.



Lecture 6 : Undefined vs Not Defined and Lossely typed language

1.Undefined is a Special Placeholder which is used to reserve memory for the variables in the memory creation phase. Even before a single line of code is executed JS engine assigns undefined to the variables.

2. Not Defined means if we try to console or access any variable which is not declared in the code then we get Not Defined error.

3. JS is a loosely typed (Flexible) language or weakly typed language means it does not attaches its variables to specific data types like in C++ and java. if we initialised a variable with data type as INT then we cannot change it but in Js we can change any int to string or string to bool.

4.Remember undefined !== not defined.




Lecture 7 : Scope Chain, Scope, Lexical Environment

# Scope : where can you access a specific variable or a function in whole code

1. Scope of a variable is directly dependent on the lexical environment.

2. Whenever an execution context is created, a lexical environment is also created. Lexical environment is the local memory of Execution Environment + reference of lexical environment of its parent.
Lexical as a term means in hierarchy or in sequence.  

3. Having the reference of parent's lexical environment means, the child or the local function can access all the variables and space of its lexical parent.

4. The JS engine first searches for a variable in the current local memory space, if its not found here it searches for the variable in the lexical environment of its parent, and if its still not found, then it searches that variable in the subsequent lexical environments, and the sequence goes on until the variable is found in some lexical environment or the lexical environment becomes NULL.

5. Scope Chain : The mechanism of searching variables in the subsequent lexical environments is known as Scope Chain. If a variable is not found anywhere, then we say that the variable is not present in the scope chain.



Lecture 8 : let , const and Temporal Dead Zone


1. Que : is 'let' and 'const' functions are hoisted? 
ans : Yes (but in script (seperate memory block) temporal dead-zone)

take a sample program

console.log(b);
let a= 10;
var b= 100;

2. we made var declaration to 'b' and let to 'a' and here comes the difference: the var declaration will come under global declaration and let declaration in script (separate memory space) and these variables are not accessible unless they are assigned with certain values

3. Temporal dead Zone : so the temporal dead zone is the time between saving variables in memory-space and actually value assigned to it by engine itself. In this time frame you can't access the variable, by hoisting, Engine stores the Variable in 'Variable environment'(Memory component) and until the line where the actual variable is assigned to its value (until then variable, remains in temporal dead zone)

4. We cannot redeclare the same variable with let/const(even with using var the second time).

5. const variable declaration and initialisation must be done on the same line.

6. Types of error: 
    [1] referenceError : given where variable does not have memory allocation. (accessing a let/const variable which is not being assigned a value)
    [2] typeError : given when we change type that is not supposed to be changed (in case of const if we change the value of const variable).
    [3] syntaxError : when proper syntax(way of writing a statement) is not used.


7. Declaration Type
    1. var = saved in Global execution context, can be assigned later and modified in script.
    2. let = saved in script execution context, temporal deadzone affects it and can later modified in script.
    3. const = saved in script execution context, temporal deadzone affects it and must be defined (assign values) when defining variable by it (cannot remained as 'undefined').


Note : 
    1. Use const wherever possible followed by let, Use var as little as possible(only if you have to). It helps avoid error.

    2. For Avoiding TDZ : Initialising variables at the top is good idea, helps shrinks TDZ to zero. 



Lecture 9 : Block , Scope , Shadowing


1. Code inside curly bracket is called block.

2. Block : Block or compound statement are code inside a curly brackets ({}). .JavaScript sometimes expect to run a single statement to run, but we need to run commands with multiple statements which is only possible by block

3. Scope :- scope of a variable or a function is the place where these are accessible.

3. Block scope : means that what all variables and functions that can access in block. Block scope also follows lexical scope chain pattern while accessing the variable. Let and const are block scope means, they are stored in separate memory space which is reserved for these block.

4. Shadowing : Shadowing in js, means if we declare the variable and the same named variable outside the block then the variable inside the block will shadows the outside block variable. The shadow should not cross the scope of original otherwise it will give error.

5. Illegal shadowing : let with var is illegal shadowing and gives error. Illegal shadowing happens when a let or const is shadowed using var in block scope. But in function scope this is allowed.

let a = 200;
{
    var a =20;
}


Lecture 10 : Closure


1. Que : What is closure?
Ans : The function bundled with its lexical environment closed to that function

simply function + Lexical scope

and closures have very special place in runtime environment

2. Amazing thing about Functions in JS : The fun in JavaScript is you can assign a variable for a function and also you can pass function as a parameter even you can return the function in JavaScript!!


3. Que : What does the closure do in my JavaScript programs?
Ans : Whenever I call a function in JavaScript the closure maintains its values(lexical env.) and function in its own runtime and when that specific function executed, it returns with own environment even the variable vanished after its execution


eg : 
function x(){
    var a = 1;
    function y(){
        clg(a);
    }
    a = 100; ->for Edge case
    retrun y;
}

var z = x();
clg(z);       -> print Whole funtion you

z();   --> 1 

4. Que : Why here 1 will gets print even the execution context of function x has been poped out 

Ans : EC is poped out but when we the closure is returned it knows its lexical environment means function y still Remembers the reference to the varible "a" not the value.


5. Edge Cases : 
    a. As variable value is changed before executing the return (the function) Value will be 100

    b. In closures, values in variable are 'pass by reference' hence there values can be changed, and whenever comes the closure inside closure(multilevel one) we can see the function refers the 'parent' variable 



Lecture 11 : setTimeout + closures

1. setTimeout stores the function in a different place and attached a timer to it, when the timer is finished it rejoins the call stack and executed.
2. Without closure the var reference gives the latest value as it does not retain the original value but rather has the reference so any update in value after timeout will be shown.
3. If we use let/const because they have block scope, every time a new copy of variable is attached, thus this can be done without closure.




